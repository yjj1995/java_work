# instanceof 操作符
x instanceof A:检验x是否为类A的对象，返回值为boolean型。
- 要求x所属的类与类A必须是子类和父类的关系，否则编译错误。
- 如果x属于类A的子类B，x instanceof A值也为true.

# Object类
- object 类时所有java类的根父类。（基类）
- 如果在类的声明中未使用extends 关键字指明其父类 ，则默认父类为Object类。
- 多层继承，处于最高层的父类一定是Object类。

## Object类中的主要方法
1. public Object()  构造 构造方法
2. public boolean equals(Object obj) 普通 对象比较 
3. public int hashCode() 普通 取到Hash码
4. public String toString() 普通 对象打印时调用

## 对象类型转换
- 基本数据类型的装欢
1. 自动类型转换： 小的数据类型可以自动转换成大的数据类型
如 long g = 20; double d = 12.0f
2. 强制类型转换：可以把大的数据类型强制转换成小的数据类型。
如 float f = (float)12.0; int a = (int)1200L
- 对java对象的强制类型转换称为造型
1. 从子类到父类的类型转换可以自动进行
2. 从父类到子类的类型转换必须通过造型（强制类型转换）实现
3. 从无继承关系的引用类型间是非法的。

## ==操作符与equals方法
- ==:
1. 基本类型比较值：直要两个变量的值相等，即为true
 int a=5;if(a==6){....}
2. 引用类型比较引用(是否指向同一个对象): 只有指向同一个对象时，==才返回true.
`Person p1 = new Person();
Person p2 = new Person()
if(p1 == p2){.....}`
- 用"==" 进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错。
- 'equals' 只能比较引用类型，其作用与"==" 相同， 比较是否指向同一个对象。

- 对于对象来说，特殊的类，String File Date 使用==是比较对象的地址，而对于equals 比较的内容
- 其它情况都是比较对象的类型。
- equals可以重写

- 字面量创建对象的时候，只在常量池创建一个对象，new的时候，常量池有对象，堆中也有对象。 字面量方法要new省内存。
- equals 对String 是比较内容的值。    

## 包装类
`Integer i = new Integer("ss")` 不报错，但是编译出错。

- 基本数据类型包装成包装类的实例
- 获得包装类对象中包装的基本数据类型变量 
- 基本数据类型的包装类： 基本数据类型与字符串直接的转化。

## 父类Object的toString 方法就输出当前对象的内存地址。其他功能需要重写。
- 打印对象的时候，相当于指向打印toString

## static 静态的
- 类变量 （静态变量）
1. 不用实例化的变量（加上static） 
`static String country Chinese.country = "国" 而不用 实例化一个对象'`
2. 需要实例化的变量: 实例化变量

- 类方法（工具类）
1. 有些方法不想因为对象的不同而频繁的new对象去调用方法，方法就写成static
2. 类变量，可以被实例化对象共享的属性，使用要慎重，一个一改全都得改。
3. 内部不能使用this， this表示的对象。

## 单例设计模式
- 设计模式就是在我们实际编程过程中，逐渐总结出的一些问题得套路。
- 单例：就是只有一个实例化对象。
- 在整个软件系统运行过程中，这个类之内实例化一次，之后只调用这个对象。（实例化创建对要消耗大量
得资源）
- 使用单例模式解决什么问题？一般都是new 对象太费劲，或者频频的new新的对象没有必要。
- 饿汉式/懒汉式
1. 懒汉式 用第一次的new
2. 饿汉式 类加载之后，还没有人调用的时候，就先new好一个对象，
以后不论谁来调用getinstance方法，都是直接返回之前new的对象。
